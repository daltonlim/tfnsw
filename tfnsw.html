<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wolli Creek Dashboard</title>

<style>
:root {
    --bg: #111;
    --panel: #161616;
    --text: #ffffff;
    --muted: rgba(255,255,255,0.55);
    --faint: rgba(255,255,255,0.35);
    --urgent: #ffb000;

    --t4: #2d6cdf;
    --t8: #1aa15f;

    --font: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}

* { box-sizing: border-box; }

body {
    margin: 0;
    height: 100vh;
    width: 100vw;
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
}

#grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    height: 100vh;
    width: 100vw;
    gap: 1px;
    background: #000;
}

/* ───────── Setup Overlay ───────── */

#setup-overlay {
    position: fixed;
    inset: 0;
    background: #fff;
    color: #000;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    text-align: center;
}

input {
    font-size: 18px;
    padding: 12px;
    width: 320px;
    margin: 16px 0;
    border: 2px solid #000;
}

button {
    font-size: 18px;
    padding: 10px 28px;
    background: #000;
    color: #fff;
    border: none;
    cursor: pointer;
}

/* ───────── Quadrants ───────── */

.quadrant {
    background: var(--panel);
    display: flex;
    flex-direction: column;
    padding: 24px;
    gap: 14px;
}

/* Alternate colors: top right and bottom left are white with black text */
#q-city-t8,
#q-south-t4 {
    background: #fff;
    color: #000;
}

#q-city-t8 .meta-secondary,
#q-south-t4 .meta-secondary {
    color: rgba(0, 0, 0, 0.55);
}

#q-city-t8 .meta-next,
#q-south-t4 .meta-next {
    color: rgba(0, 0, 0, 0.35);
}

#q-city-t8 .direction,
#q-south-t4 .direction {
    opacity: 0.65;
}

#q-city-t8 .timer .unit,
#q-south-t4 .timer .unit {
    opacity: 0.55;
}

/* Header row */
.header {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 2.4vh;
    font-weight: 700;
    letter-spacing: 0.06em;
}

.line-pill {
    padding: 4px 10px;
    border-radius: 999px;
    font-weight: 800;
    font-size: 0.9em;
}

.t4 { background: var(--t4); }
.t8 { background: var(--t8); }

.direction {
    text-transform: uppercase;
    opacity: 0.85;
}

/* Time */
.timer {
    font-size: 11vh;
    font-weight: 900;
    line-height: 0.95;
    letter-spacing: -0.02em;
}

.timer .unit {
    font-size: 0.38em;
    font-weight: 700;
    opacity: 0.75;
    margin-left: 4px;
}

/* Meta */
.meta {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.meta-primary {
    font-size: 2.4vh;
    font-weight: 700;
}

.meta-secondary {
    font-size: 2.2vh;
    color: var(--muted);
}

.meta-next {
    font-size: 2.2vh;
    color: var(--faint);
}

/* Urgent state (JS can toggle this) */
.urgent .timer {
    color: var(--urgent);
}

/* Footer bits */
#updated-at {
    position: fixed;
    top: 6px;
    right: 10px;
    font-size: 10px;
    color: var(--faint);
}

#reset-btn {
    position: fixed;
    bottom: 6px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 10px;
    opacity: 0.25;
    background: none;
    color: #888;
    border: 1px solid #666;
}
</style>
</head>

<body>

<div id="setup-overlay">
    <h1>Enter TfNSW API key</h1>
    <p>Stored locally so you do not need to re-enter next time.</p>
    <input id="api-key-input" type="password" placeholder="Ocp-Apim-Subscription-Key">
    <button id="start-btn">Start</button>
    <div id="error"></div>
</div>

<div id="grid">

    <div class="quadrant" id="q-city-t4">
        <div class="header">
            <span class="line-pill t4">T4</span>
            <span class="direction">→ To City</span>
        </div>
        <div class="timer" data-line="T4" data-direction="city">
            --<span class="unit">m</span>
        </div>
        <div class="meta" data-meta="T4-city">
            <div class="meta-primary">Waiting for data…</div>
        </div>
    </div>

    <div class="quadrant" id="q-city-t8">
        <div class="header">
            <span class="line-pill t8">T8</span>
            <span class="direction">→ To City</span>
        </div>
        <div class="timer" data-line="T8" data-direction="city">
            --<span class="unit">m</span>
        </div>
        <div class="meta" data-meta="T8-city">
            <div class="meta-primary">Waiting for data…</div>
        </div>
    </div>

    <div class="quadrant" id="q-south-t4">
        <div class="header">
            <span class="line-pill t4">T4</span>
            <span class="direction">← Away</span>
        </div>
        <div class="timer" data-line="T4" data-direction="south">
            --<span class="unit">m</span>
        </div>
        <div class="meta" data-meta="T4-south">
            <div class="meta-primary">Waiting for data…</div>
        </div>
    </div>

    <div class="quadrant" id="q-south-t8">
        <div class="header">
            <span class="line-pill t8">T8</span>
            <span class="direction">← Away</span>
        </div>
        <div class="timer" data-line="T8" data-direction="south">
            --<span class="unit">m</span>
        </div>
        <div class="meta" data-meta="T8-south">
            <div class="meta-primary">Waiting for data…</div>
        </div>
    </div>

</div>

<button id="reset-btn">Reset</button>
<div id="updated-at"></div>

    <script>
        // Minimal single-file dashboard for Wolli Creek departures.
        const WALK_BUFFER_MIN = 5; // time to walk from house to station
        const STATION_NAME = "Wolli Creek Station";
        const REFRESH_MS = 30_000;
        const PROXY_URL = "http://localhost:3000"; // local proxy to handle CORS

        const overlay = document.getElementById("setup-overlay");
        const apiInput = document.getElementById("api-key-input");
        const errorBox = document.getElementById("error");
        const updatedAt = document.getElementById("updated-at");

        const resetBtn = document.getElementById("reset-btn");
        const timers = document.querySelectorAll(".timer");

        resetBtn.addEventListener("click", () => {
            localStorage.removeItem("tfnswApiKey");
            location.reload();
        });

        document.getElementById("start-btn").addEventListener("click", () => {
            const key = apiInput.value.trim();
            if (!key) {
                setError("Please enter a valid TfNSW subscription key.");
                return;
            }
            localStorage.setItem("tfnswApiKey", key);
            hideOverlay();
            init();
        });

        const saved = localStorage.getItem("tfnswApiKey");
        if (saved) {
            apiInput.value = saved;
            hideOverlay();
            init();
        }

        function hideOverlay() {
            overlay.style.display = "none";
        }

        function setError(msg) {
            errorBox.textContent = msg;
        }

        async function init() {
            try {
                await refresh();
                setInterval(refresh, REFRESH_MS);
            } catch (err) {
                setError(err.message || String(err));
                overlay.style.display = "flex";
            }
        }

        async function refresh() {
            const key = localStorage.getItem("tfnswApiKey");
            if (!key) return;

            const stopId = await resolveStopId(key, STATION_NAME);
            const departures = await fetchDepartures(key, stopId);

            const slots = {
                "T4-city": pickNext(departures, "T4", true),
                "T8-city": pickNext(departures, "T8", true),
                "T4-south": pickNext(departures, "T4", false),
                "T8-south": pickNext(departures, "T8", false),
            };

            Object.entries(slots).forEach(([slot, info]) => updateSlot(slot, info));
            updatedAt.textContent = `Updated ${new Date().toLocaleTimeString()}`;
        }

        function pickNext(list, line, toCity) {
            // Heuristic destination matching to split city-bound vs away.
            const cityHints = ["Central", "Town Hall", "Wynyard", "Circular Quay", "Martin Place", "Redfern", "City Circle", "Museum", "St James", "Green Square", "Airport", "Domestic", "International", "Mascot"];
            const lineMatches = list.filter(item => item.line.startsWith(line));
            const dirMatches = lineMatches
                .filter(item => toCity ? cityHints.some(h => item.destination.includes(h)) : !cityHints.some(h => item.destination.includes(h)))
                .sort((a, b) => a.departure - b.departure);
            return { service: dirMatches[0], next: dirMatches[1], next2: dirMatches[2], totalLine: lineMatches.length, totalDir: dirMatches.length };
        }

        function updateSlot(slotKey, info) {
            const [line, dir] = slotKey.split("-");
            const timerEl = document.querySelector(`.timer[data-line="${line}"][data-direction="${dir.includes("city") ? "city" : "south"}"]`);
            const metaEl = document.querySelector(`[data-meta="${slotKey}"]`);
            const service = info?.service;
            if (!service) {
                timerEl.textContent = "--";
                metaEl.textContent = `No service found soon (${info?.totalDir || 0}/${info?.totalLine || 0})`;
                return;
            }

            const leaveInMin = Math.floor((service.departure - Date.now()) / 60000) - WALK_BUFFER_MIN;
            timerEl.textContent = formatLeave(leaveInMin);
            const depTime = new Date(service.departure).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
            
            const nextLines = [];
            if (info?.next) {
                const nextLeaveInMin = Math.floor((info.next.departure - Date.now()) / 60000) - WALK_BUFFER_MIN;
                const nextDepTime = new Date(info.next.departure).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
                nextLines.push(`<div class="meta-line meta-next">Next: ${info.next.destination} at ${nextDepTime} (${formatLeave(nextLeaveInMin)})</div>`);
            }
            if (info?.next2) {
                const next2LeaveInMin = Math.floor((info.next2.departure - Date.now()) / 60000) - WALK_BUFFER_MIN;
                const next2DepTime = new Date(info.next2.departure).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
                nextLines.push(`<div class="meta-line meta-next">Then: ${info.next2.destination} at ${next2DepTime} (${formatLeave(next2LeaveInMin)})</div>`);
            }
            
            metaEl.innerHTML = `<div class="meta-line meta-primary">${service.destination} at ${depTime} (${formatLeave(leaveInMin)})</div>${nextLines.join('')}`;
        }

        function formatLeave(mins) {
            const m = mins;
            if (m < 0) return `${m}m`;
            if (m < 60) return `${m}m`;
            const h = Math.floor(m / 60);
            const rem = m % 60;
            if (rem === 0) return `${h}h`;
            return `${h}h ${rem}m`;
        }

        async function resolveStopId(key, name) {
            const url = new URL(PROXY_URL + "/stop_finder");
            url.searchParams.set("name", name);
            const resp = await fetch(url, { headers: { "x-api-key": key }, cache: "no-store" });
            if (!resp.ok) throw new Error("Unable to find stop id. Check API key/proxy.");
            const data = await resp.json();
            const match = data?.locations?.find(loc => loc.type === "stop" || loc.type === "station");
            if (!match) throw new Error("Stop not found for " + name);
            return match.id;
        }

        async function fetchDepartures(key, stopId) {
            const url = new URL(PROXY_URL + "/departures");
            url.searchParams.set("stopId", stopId);

            const resp = await fetch(url, { headers: { "x-api-key": key }, cache: "no-store" });
            if (!resp.ok) throw new Error("Failed to load departures. Check key/quota.");
            const data = await resp.json();
            const raw = data?.stopEvents || [];
            return raw.map(ev => {
                const prod = ev.transportation?.number || ev.transportation?.name || "";
                const dest = ev.transportation?.destination?.name || "";
                const planned = ev.dateTime?.target || ev.departureTimePlanned;
                const realtime = ev.dateTime?.rt || ev.departureTimeEstimated;
                const ts = (realtime || planned) ? new Date(realtime || planned).getTime() : 0;
                return { line: (prod || "").toUpperCase(), destination: dest, departure: ts };
            }).filter(item => item.departure > Date.now());
        }
    </script>
</body>
</html>